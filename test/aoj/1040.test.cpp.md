---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: graph/edge.cpp
    title: graph/edge.cpp
  - icon: ':heavy_check_mark:'
    path: graph/minimum_steiner_tree.hpp
    title: Minimum Steiner Tree
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1040
    links:
    - http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1040
  bundledCode: "#line 1 \"test/aoj/1040.test.cpp\"\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1040\"\
    \n\n#line 2 \"graph/edge.cpp\"\n\ntemplate <typename T>\nstruct Edge {\n    int\
    \ from, to;\n    T weight;\n    Edge() = default;\n    Edge(int to, T weight)\
    \ : from(-1), to(to), weight(weight) {}\n    Edge(int from, int to, T weight)\
    \ : from(from), to(to), weight(weight) {}\n};\n#line 2 \"graph/minimum_steiner_tree.hpp\"\
    \n#include <algorithm>\n#include <limits>\n#include <queue>\n#include <utility>\n\
    #include <vector>\n#line 8 \"graph/minimum_steiner_tree.hpp\"\n\ntemplate <typename\
    \ T>\nT minimum_steiner_tree(std::vector<std::vector<Edge<T>>>& G, std::vector<int>&\
    \ terminals) {\n    const int n = G.size();\n    const int t = terminals.size();\n\
    \    constexpr T INF = std::numeric_limits<T>::max() / 2;\n    using P = std::pair<T,\
    \ int>;\n\n    std::vector<std::vector<T>> dp(1 << t, std::vector<T>(n, INF));\n\
    \    for (int i = 0; i < t; ++i) dp[1 << i][terminals[i]] = 0;\n\n    for (int\
    \ S = 1; S < (1 << t); ++S) {\n        for (int i = 0; i < n; ++i) {\n       \
    \     for (int U = S; U > 0; U = (U - 1) & S) {\n                dp[S][i] = std::min(dp[S][i],\
    \ dp[S ^ U][i] + dp[U][i]);\n            }\n        }\n        if (S == (1 <<\
    \ t) - 1) continue;\n        std::priority_queue<P, std::vector<P>, std::greater<>>\
    \ pq;\n        for (int i = 0; i < n; ++i) {\n            pq.emplace(dp[S][i],\
    \ i);\n        }\n        while (!pq.empty()) {\n            auto [d, v] = pq.top();\n\
    \            pq.pop();\n            if (dp[S][v] < d) continue;\n            for\
    \ (auto& e : G[v]) {\n                if (dp[S][e.to] > d + e.weight) {\n    \
    \                dp[S][e.to] = d + e.weight;\n                    pq.emplace(dp[S][e.to],\
    \ e.to);\n                }\n            }\n        }\n    }\n\n    return dp.back()[terminals[0]];\n\
    }\n#line 5 \"test/aoj/1040.test.cpp\"\n\n#include <bits/stdc++.h>\nusing namespace\
    \ std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\
    \    cout << fixed << setprecision(15);\n\n    while (true) {\n        int H,\
    \ W;\n        cin >> H >> W;\n        if (H == 0) break;\n        vector<vector<Edge<int>>>\
    \ G(H*W);\n        vector<int> terminals;\n        for (int i = 0; i < H; ++i)\
    \ {\n            for (int j = 0; j < W; ++j) {\n                int s;\n     \
    \           cin >> s;\n                if (s) terminals.push_back(i*W+j);\n  \
    \              if (i < H-1) {\n                    G[i*W+j].push_back({(i+1)*W+j,\
    \ 1});\n                    G[(i+1)*W+j].push_back({i*W+j, 1});\n            \
    \    }\n                if (j < W-1) {\n                    G[i*W+j].push_back({i*W+j+1,\
    \ 1});\n                    G[i*W+j+1].push_back({i*W+j, 1});\n              \
    \  }\n            }\n        }\n        cout << H*W - minimum_steiner_tree(G,\
    \ terminals) - 1 << endl;\n    }\n}\n"
  code: "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1040\"\
    \n\n#include \"../../graph/edge.cpp\"\n#include \"../../graph/minimum_steiner_tree.hpp\"\
    \n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n\
    \    cin.tie(nullptr);\n    cout << fixed << setprecision(15);\n\n    while (true)\
    \ {\n        int H, W;\n        cin >> H >> W;\n        if (H == 0) break;\n \
    \       vector<vector<Edge<int>>> G(H*W);\n        vector<int> terminals;\n  \
    \      for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j)\
    \ {\n                int s;\n                cin >> s;\n                if (s)\
    \ terminals.push_back(i*W+j);\n                if (i < H-1) {\n              \
    \      G[i*W+j].push_back({(i+1)*W+j, 1});\n                    G[(i+1)*W+j].push_back({i*W+j,\
    \ 1});\n                }\n                if (j < W-1) {\n                  \
    \  G[i*W+j].push_back({i*W+j+1, 1});\n                    G[i*W+j+1].push_back({i*W+j,\
    \ 1});\n                }\n            }\n        }\n        cout << H*W - minimum_steiner_tree(G,\
    \ terminals) - 1 << endl;\n    }\n}\n"
  dependsOn:
  - graph/edge.cpp
  - graph/minimum_steiner_tree.hpp
  isVerificationFile: true
  path: test/aoj/1040.test.cpp
  requiredBy: []
  timestamp: '2022-06-27 14:23:07+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: test/aoj/1040.test.cpp
layout: document
redirect_from:
- /verify/test/aoj/1040.test.cpp
- /verify/test/aoj/1040.test.cpp.html
title: test/aoj/1040.test.cpp
---
