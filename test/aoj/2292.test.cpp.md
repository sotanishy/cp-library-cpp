---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: string/palindromic_tree.hpp
    title: Palindromic Tree
  - icon: ':heavy_check_mark:'
    path: string/rolling_hash.hpp
    title: Rolling Hash
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2292
    links:
    - http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2292
  bundledCode: "#line 1 \"test/aoj/2292.test.cpp\"\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2292\"\
    \n\n#line 2 \"string/palindromic_tree.hpp\"\n#include <map>\n#include <ranges>\n\
    #include <string>\n#include <vector>\n\nclass PalindromicTree {\n   public:\n\
    \    PalindromicTree() : nodes(2) {\n        nodes[0] = Node(-1, -1, 0);  // root\
    \ for odd length palindromes\n        nodes[1] = Node(0, -1, 0);   // root for\
    \ even length palindromes\n        nodes[1].suffix_link = 0;\n        suff = 0;\n\
    \    }\n\n    explicit PalindromicTree(const std::string& s) : PalindromicTree()\
    \ {\n        for (char c : s) add(c);\n    }\n\n    void add(char c) {\n     \
    \   str.push_back(c);\n\n        //  find a palidrome cAc\n        int k = find_next_palindrome(suff);\n\
    \n        // the palindrome already exists\n        if (nodes[k].link.contains(c))\
    \ {\n            ++nodes[nodes[k].link[c]].cnt;\n            suff = nodes[k].link[c];\n\
    \            return;\n        }\n\n        // create a new node\n        nodes[k].link[c]\
    \ = nodes.size();\n        suff = nodes.size();\n        nodes.emplace_back(nodes[k].len\
    \ + 2, (int)str.size() - nodes[k].len - 2,\n                           1);\n\n\
    \        // add a suffix link\n        if (nodes.back().len == 1) {\n        \
    \    nodes.back().suffix_link = 1;\n        } else {\n            const int n\
    \ = find_next_palindrome(nodes[k].suffix_link);\n            nodes.back().suffix_link\
    \ = nodes[n].link[c];\n        }\n    }\n\n    std::vector<int> get_suffix_palindromes()\
    \ const {\n        std::vector<int> ret;\n        int k = suff;\n        while\
    \ (nodes[k].len > 0) {\n            ret.push_back(nodes[k].len);\n           \
    \ k = nodes[k].suffix_link;\n        }\n        return ret;\n    }\n\n    // returns\
    \ {length, one of the starting indices, count}\n    std::vector<std::tuple<int,\
    \ int, int>> get_palindrome_frequencies() {\n        std::vector<std::tuple<int,\
    \ int, int>> ret;\n        for (auto& node : nodes | std::views::drop(2) | std::views::reverse)\
    \ {\n            ret.emplace_back(node.len, node.idx, node.cnt);\n           \
    \ nodes[node.suffix_link].cnt += node.cnt;\n        }\n        return ret;\n \
    \   }\n\n   private:\n    struct Node {\n        std::map<char, int> link;\n \
    \       int suffix_link;\n        int len, idx, cnt;\n\n        Node() = default;\n\
    \        Node(int len, int idx, int cnt) : len(len), idx(idx), cnt(cnt) {}\n \
    \   };\n\n    std::vector<Node> nodes;\n    int suff;\n    std::string str;\n\n\
    \    int find_next_palindrome(int k) const {\n        const int pos = str.size()\
    \ - 1;\n        while (true) {\n            int i = pos - 1 - nodes[k].len;\n\
    \            if (i >= 0 && str[i] == str[pos]) break;\n            k = nodes[k].suffix_link;\n\
    \        }\n        return k;\n    }\n};\n#line 2 \"string/rolling_hash.hpp\"\n\
    #include <random>\n#line 5 \"string/rolling_hash.hpp\"\n\nclass RollingHash {\n\
    \   public:\n    static long long generate_base() {\n        std::random_device\
    \ rd;\n        std::mt19937_64 rng(rd());\n        std::uniform_int_distribution<long\
    \ long> rand(1, mod - 1);\n        return rand(rng);\n    }\n\n    RollingHash()\
    \ = default;\n    RollingHash(const std::string& s, long long base)\n        :\
    \ RollingHash(std::vector<char>(s.begin(), s.end()), base) {}\n    template <typename\
    \ T>\n    RollingHash(const std::vector<T>& s, long long base)\n        : base(base),\
    \ hashed(s.size() + 1), power(s.size() + 1) {\n        power[0] = 1;\n       \
    \ for (int i = 0; i < (int)s.size(); ++i) {\n            power[i + 1] = mul(power[i],\
    \ base);\n            hashed[i + 1] = add(mul(hashed[i], base), s[i]);\n     \
    \   }\n    }\n\n    long long query(int l, int r) const {\n        return add(hashed[r],\
    \ mod - mul(hashed[l], power[r - l]));\n    }\n\n    long long combine(long long\
    \ h1, long long h2, int len2) const {\n        return add(mul(h1, power[len2]),\
    \ h2);\n    }\n\n    void push_back(char c) {\n        power.push_back(mul(power.back(),\
    \ base));\n        hashed.push_back(add(mul(hashed.back(), base), c));\n    }\n\
    \n   private:\n    static constexpr long long mod = (1LL << 61) - 1;\n\n    static\
    \ inline long long add(long long a, long long b) {\n        if ((a += b) >= mod)\
    \ a -= mod;\n        return a;\n    }\n\n    static inline long long mul(long\
    \ long a, long long b) {\n        __int128_t c = (__int128_t)a * b;\n        return\
    \ add(c >> 61, c & mod);\n    }\n\n    const long long base;\n    std::vector<long\
    \ long> hashed, power;\n};\n#line 5 \"test/aoj/2292.test.cpp\"\n\n#include <bits/stdc++.h>\n\
    using namespace std;\nusing ll = long long;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n\
    \    cin.tie(nullptr);\n    cout << fixed << setprecision(15);\n\n    string s,\
    \ t;\n    cin >> s >> t;\n    PalindromicTree pts(s), ptt(t);\n    ll base = RollingHash::generate_base();\n\
    \    RollingHash rhs(s, base), rht(t, base);\n    map<ll, ll> mp;\n    for (auto\
    \ [len, idx, cnt] : pts.get_palindrome_frequencies()) {\n        mp[rhs.query(idx,\
    \ idx+len)] += cnt;\n    }\n    ll ans = 0;\n    for (auto [len, idx, cnt] : ptt.get_palindrome_frequencies())\
    \ {\n        ans += mp[rht.query(idx, idx+len)] * cnt;\n    }\n    cout << ans\
    \ << endl;\n}\n"
  code: "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2292\"\
    \n\n#include \"../../string/palindromic_tree.hpp\"\n#include \"../../string/rolling_hash.hpp\"\
    \n\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n\
    int main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n \
    \   cout << fixed << setprecision(15);\n\n    string s, t;\n    cin >> s >> t;\n\
    \    PalindromicTree pts(s), ptt(t);\n    ll base = RollingHash::generate_base();\n\
    \    RollingHash rhs(s, base), rht(t, base);\n    map<ll, ll> mp;\n    for (auto\
    \ [len, idx, cnt] : pts.get_palindrome_frequencies()) {\n        mp[rhs.query(idx,\
    \ idx+len)] += cnt;\n    }\n    ll ans = 0;\n    for (auto [len, idx, cnt] : ptt.get_palindrome_frequencies())\
    \ {\n        ans += mp[rht.query(idx, idx+len)] * cnt;\n    }\n    cout << ans\
    \ << endl;\n}\n"
  dependsOn:
  - string/palindromic_tree.hpp
  - string/rolling_hash.hpp
  isVerificationFile: true
  path: test/aoj/2292.test.cpp
  requiredBy: []
  timestamp: '2024-01-07 23:25:49+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: test/aoj/2292.test.cpp
layout: document
redirect_from:
- /verify/test/aoj/2292.test.cpp
- /verify/test/aoj/2292.test.cpp.html
title: test/aoj/2292.test.cpp
---
